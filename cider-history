;; -*- coding: utf-8-unix -*-
;; Automatically written history of CIDER REPL session
;; Edit at your own risk

("(is-dev?)" "(ns dots.dev)" "(ns 'dots.dev)" "(in-ns 'dots.components.board)" "(run)" "(let [x 1]
        (+ 1 x))" "(+ 1 2)" "(get {0 :a} 0)" "(name {0 :green, 1 :yellow, 2 :red, 3 :yellow, 4 :purple, 5 :blue})" "(0 {0 :green, 1 :yellow, 2 :red, 3 :yellow, 4 :purple, 5 :blue})" "(name {0 :green, 1 :yellow, 2 :red, 3 :yellow, 4 :purple, 5 :blue})" "(name 0)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(map (fn [[col m]] {col m}) {0 {:foo 1} 1 {:foo 2}})" "(map (fn [[col m]] m) {0 {:foo 1} 1 {:foo 2}})" "(apply merge (for [col (range 6)]
             {col {:column col
                   :rows-map (zipmap (range 6)
                                     (repeat 6 :blue))}}))" "(for [col (range 6)]
             {col {:column col
                   :rows-map (zipmap (range 6)
                                     (repeat 6 :blue))}})" "(doseq [col (range 6)]
             {col {:column col
                   :rows-map (zipmap (range 6)
                                     (repeat 6 :blue))}})" "(repeat 6 1)" "(doseq [col (range 6)]
             {col {:column col
                   :rows-map (zipmap (range 6)
                                     :blue)}})" "(def board-size 6)" "(doseq [col (range board-size)]
             {col {:column col
                   :rows-map (zipmap (range board-size)
                                     :blue)}})" "(apply merge (for [col (range board-size)]
                          {col {:column col
                                :rows-map (zipmap (range board-size)
                                                  :blue)}}))" "(apply merge (doseq [col (range board-size)]
                          {col {:column col
                                :rows-map (zipmap (range board-size)
                                                  :blue)}}))" "(browser-repl)" "(run)" "(set [1 2 3 3])" "(set 1 2 3 4 5)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(first [1 2])" "(map first [1 2] [3 4])" "(map + 1 2 3)" "(+ 1 2)" "(let [dots [{:foo 1 :bar 2} {:foo 2 :bar 2}]
                 max-dots (apply max (map :foo dots))]
             (into [] (filter #(= max-dots (:foo %)) dots)))
             " "(let [dots [{:foo 1 :bar 2} {:foo 2 :bar 2}]
                 max-dots (apply max (map :foo dots))]
             (filter #(= max-dots (:foo %)) dots))
             " "(apply max (map :foo [{:foo 1 :bar 2} {:foo 2 :bar 2}]))" "(browser-repl)" "(run)" ":cljs/quit" "(apply max (map :foo [{:foo 1} {:foo 2}]))" "(map :foo [{:foo 1} {:foo 2}])" "(max (map :foo [{:foo 1} {:foo 2}]))" "(keyword \"hey\")" "(key \"hey\")" "(and 1 nil true)" "(and 1 0 true)" "(and true true true)" "(browser-repl)" "(run)" ":cljs/quit" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(in-ns 'dots.chans)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" "(run)" ":cljs/quit" "(run)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" "(clojure.string/reverse \"Hello World\")" ":cljs/quit" "(def c (async/chan))
(def p (async/pub c :topic))
(async/put! c {:topic :foo})" "(in-ns 'dots.components.board)" "(browser-repl)" "(run)" ":cljs/quit" "(go-loop)" "(require-macros '[cljs.core.async.macros :refer [go-loop]])
                               " "(+ 1 2)" "(go (let [c (async/chan)]
                             (async/put! c {:topic :foo})
                             (:topic (<! c))))
                               " "(+ 1 2)" "(go (let [c (async/chan)]
                             (async/put! c {:topic :foo})
                             (let [v (<! c)]
                               (println v))))" "(+ 1 2)" "(go (let [c (async/chan)]
                             (>! c {:topic :foo})
                             (let [v (<! c)]
                               (println v))))" "(+ 1 2)" "(go (let [c (async/chan)]
                             (async/put! c {:topic :foo})
                             (let [v (<! c)]
                               (println v))))" "(let [x {}]
                         (go (let [c (async/chan)]
                               (async/put! c {:topic :foo})
                               (let [v (<! c)]
                                 (merge x {:foo v}))))
                         x)" "(go (let [c (async/chan)]
                             (async/put! c {:topic :foo})
                             (let [v (<! c)]
                               (println v))))" "(let [x {}]
                         (go (let [c (async/chan)]
                               (async/put! c {:topic :foo})
                               (let [v (<! c)]
                                 (merge x {:foo v}))))
                         x)" "(let [x {}]
                         (go (let [c (async/chan)]
                               (async/put! c {:topic :foo})
                               (let [v (<! c)]
                                 (merge x {:foo v}))))
                         x)
                               " "(let [x {}]
                         (go (let [c (async/chan)]
                               (async/put! c {:topic :foo})
                               (let [v (<! c)]
                                 (merge x {:foo v}))))
                         x)" "(let [x {}]
                         (go (let [c (async/chan)]
                               (async/put! c {:topic :foo})
                               (let [v (<! c)]
                                 (merge x {:foo v}))))
                         )" "(let [x {}]
                         (go (let [c (async/chan)]
                               (async/put! c {:topic :foo})
                               (let [v (<! c)]
                                 (merge x {:foo v})))))" "(let [x {}]
                         (go (let [c (async/chan)]
                               (async/put! c {:topic :foo})
                               (let [v (<! c)]
                                 (merge x {:foo v}))))
                         x)
                               " "(go (let [c (async/chan)]
                             (async/put! c {:topic :foo})
                             (let [v (<! c)]
                               (println v))))" "(go (let [c (async/chan)]
                             (async/put! c {:topic :foo})
                             (let [v (<! c)]
                               println v)))" "(go (let [c (async/chan)]
                             (async/put! c {:topic :foo})
                             (let [v (<! c)]
                               {:foo v})))" "(let [c (async/chan)]
                         (async/put! c {:topic :foo})
                         (go (let [v (<! c)]
                               {:foo v})))" "(let [c (async/chan)]
                         (async/put! c {:topic :foo})
                         (go (type (<! c))))" "(let [c (async/chan)]
                         (async/put! c {:topic :foo}))
                         (go (type (<! c))))" "(println (go (<! my-chan)))" "(type (go (async/<! my-chan)))" "(go (async/<! my-chan))" "(type my-chan)" "my-chan" "(def my-chan (let [c (async/chan)]
                                      (async/put! c {:topic :foo})
                                      c))" "(let [c (async/chan)]
                         (async/put! c {:topic :foo})
                         c)" "(let [c (async/chan)]
                         (async/put! c {:topic :foo})
                         )" "(let [c (async/chan)]
                         (async/put! c {:topic :foo})
                         (async/take! c #(:topic %)))" "(let [c (async/chan)]
                         (async/put! c {:topic :foo})
                         (go (async/take! c #(:topic %))))" "(let [c (async/chan)]
                         (async/put! c {:topic :foo})
                         (go (:topic (async/take! c))))" "(let [c (async/chan)]
                         (async/put! c {:topic :foo})
                         (go (:topic (<! c))))" "(let [c (async/chan)]
                         (async/put! c {:topic :foo}))
                         (go (:topic (<! c))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (go (:topic (<! c))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (type (go <! (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (go <! (go (<! c))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (keys (go <! (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (:topic (go <! (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (clj->js (go <! (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (go <! (go (<! c))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (type (clj->js (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (:topic (clj->js (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (clj->js (go (<! c))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (println (clj->js (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (println (cljs->js (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (println (go (<! c))))" "(let [c (async/chan)]
                         (do
                           (go (>! c {:topic :foo}))
                           (println (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (println (go (<! c))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (go (<! c)))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo})))" "(in-ns 'dots.components.board)" "(browser-repl)" "(run)" ":cljs/quit" "(let [c (chan)]
                         c
                         )" "(put!
 
 )" "(in-ns 'dots.components.board)" "(in-ns 'dots.core)" "(in-ns 'dots.components.main)" "(in-ns 'dots.main)" "(browser-repl)" "(run)" "(let [publisher (async/chan)
                   publication (async/pub publisher #(:topic %))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (async/sub publication :foo subscriber)
               (take-and-print subscriber \"I'm the subscriber!\")
               (async/go (async/>! publisher {:topic :foo})))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (do 
                (async/sub publication :foo subscriber)
                (take-and-print subscriber \"I'm the subscriber!\")
                (async/go (async/>! publisher {:foo \"hey buddy\"}))))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (doall 
                (async/sub publication :foo subscriber)
                (take-and-print subscriber \"I'm the subscriber!\")
                (async/go (async/>! publisher {:foo \"hey buddy\"}))))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (async/sub publication :foo subscriber)
               (take-and-print subscriber \"I'm the subscriber!\")
               (async/go (async/>! publisher {:foo \"hey buddy\"})))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (async/sub publication :foo subscriber)
               (take-and-print subscriber {:foo \"foo\"})
               (async/go (async/>! publisher {:foo \"hey buddy\"})))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (async/sub publication :foo subscriber)
               (take-and-print subscriber {:foo \"foo\"})
               (async/go (>! publisher {:foo \"hey buddy\"})))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (async/sub publication :foo subscriber)
               (take-and-print subscriber {:foo \"foo\"}))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (async/sub publication :foo subscriber)
               (take-and-print subscriber \"foo\"))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (sub publication :foo subscriber)
               (take-and-print subscriber \"foo\"))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (take-and-print subscriber \"foo\"))" "(let [publisher (chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (take-and-print subscriber \"foo\"))" "(require '[clojure.core.async :as async])" ":cljs/quit" "(require '[clojure.core.async :as async])" "(browser-repl)" "(run)" "(browser-repl)" "(run)" "(repeat 6)" "(repeat 1)" "(def -dots (let [board-size 6] 
             (for [col (range board-size) row (range board-size)]
               {:column col :row row :color (rand-colors nil)})))" "-dots" "(def -dots (let [board-size 6] 
             (for [col (range board-size) row (range board-size)]
               {:column col :row row :color (rand-colors nil)})))" "(map (fn [x y] {:col x :row y}) (range 6) (range 6))" "(map {:col % :row %2} [(range 6) (range 6)])" "(map {:col % :row %2} (range 6) (range 6))" "(map #({:col % :row %2}) (range 6) (range 6))" "(map {:col % :row %2} (range 6) (range 6))" "(let [board-size 6
                             dots (for [col (range board-size) row (range board-size)]
                                    {:column col :row row :color (rand-colors nil)})]
                         (apply d/div #js {:className \"board\"} (om/build-all dot dots)))" "(let [board-size 6
                             dots (for [col (range board-size) row (range board-size)]
                                    {:column col :row row :color (rand-colors nil)})]
                         (om/build-all dot dots))" "(in-ns 'dots.components.board)" "(browser-repl)" "(run)" ":cljs/quit" "(let [board-size 6
                             dots (for [col (range board-size) row (range board-size)]
                                    {:column col :row row :color (rand-colors nil)})]
                         (om/build-all dot dots))" "(in-ns 'dots.components.board)" "(+ 1 1)" "(browser-repl)" "(run)" ":cljs/quit" "(+ 1 1)" "(browser-repl)" ":cljs/quit" "(+ 1 1 )" "q" "(browser-repl)" "(run)" "x" "(def x (for [col (range 6) row (range 6)] {:column col :row row}))" "(for [col (range 6) row (range 6)] {:column col :row row})" "(map #(zipmap [:col :row] [% %2]) (range 6) (range 6))" "(map #(zipmap [:col :row] % %2) (range 6) (range 6))" "(map #(zipmap [:col :row] %) (range 6) (range 6))" "(zipmap [:col :row] [1 2])" "(apply #(zipmap [:col :row] %) [1 2])" "(apply #(zipmap [:col :row] %) [(range 6) (range 6)])" "(apply #(zipmap [:col :row] %) [[(range 6) (range 6)]])" "(apply zipmap [[:col :row] [(range 6) (range 6)]])" "(apply zipmap [:col :row] [[(range 6) (range 6)]])" "(apply zipmap [:col :row] [(range 6) (range 6)])" "(zipmap [:col :row] [(range 6) (range 6)])" "(zipmap :col :row [(range 6) (range 6)])" "[(range 6) (range 6)]" "(range 6)" "(range 5)" "(str 23 \"px\")" "(str 23)" "(browser-repl)" "(run)" ":cljs/quit" "(+ 1 1)" "(. js/console log \"Hey\")" "(browser-repl)" "(run)" "(start-figwheel)" "(run)" "(. js/console log \"Hey\")" "(browser-repl)" "(run)" ":cljs/quit'" "(alert
            )" "(browser-repl)" ":cljs/quit" "(. js/alert \"Hey!\")" "(browser-repl)" "(run)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" "-server" "(def -server (run))" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" ":cljs/quit" "(browser-repl)" "(run)" "(d/div #js {:className \"marq\"} (om/build-all color-letter (colorize-word \"SCORE\")))
                               " "(d/div #js {:className \"marq\"} (om/build-all color-letter (colorize-word \"SCORE\"))
                               )" "(d/div #js {:className \"marq\"} (om/build-all color-letter (colorize-word \"SCORE\")))" "(apply d/div #js {:className \"marq\"} (om/build-all color-letter (colorize-word \"SCORE\")))" "(om/build-all color-letter (colorize-word \"SCORE\"))" "(colorize-word \"SCORE\")" "(defn colorize-word [word]
  (map (fn [x c] {:className (name c) :letter x}) word (rand-colors nil)))
" "(defn colorize-word [word]
  (map (fn [x c] {:className (name c) :letter x}) word (rand-colors)))
" "(in-ns 'dots.components.screen)" "(browser-repl)" "(run)" "(rand-colors)" "dot-colors" "(dot-colors)" "(om/build (d/span {:className (name \"foo\")} \"S\") nil)" "(om/build (d/span {:className (name \"foo\")} \"S\")
                     )" "(in-ns 'dots.components.screen)" "(om/build (d/span {:className (name \"foo\")} \"S\")
                     )" "(+ 1 1)" "(browser-repl)" ":cljs/quit" "(+ 1 1)" "(colorize-word \"BOO\")" "(browser-repl)" "(run)" ":cljs/quit" "(+ 1 1)" "(colorize-word \"BOO\")" "(in-ns 'dots.components.screen)" "(browser-repl)" ":cljs/quit" "(run)" ":cljs/quit" "(browser-repl)" "(run)" ":cljs/quit" "(concat [1 2 3 4])" "(om/build-all header-col [{:title \"score\" :val 0} {:title \"time\" :val 60}])" "(om/build-all header-col nil [{:state {:title \"score\" :val 0}} {:state {:title \"time\" :val 60}}])" "(om/build-all header-col [{:title \"score\" :val 0} {:title \"time\" :val 60}])" "(om/build-all header-call [{:title \"score\" :val 0} {:title \"time\" :val 60}])" "(in-ns 'dots.components.board)" "(browser-repl)" ":cljs/quit" "(. js/document getElementById \"dots-game-container\")" "(browser-repl)" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" ":cljs/quit" "(. js/document getElementById \"app\")" "(browser-repl)" ":cljs/quit" "(. js/document getElementById \"dots-game-container\")" "(. js/document getElementById \"main\")" "(. js/document getElementsByClassName \"dots-game\")" "(first (. js/document getElementsByClassName \"dots-game\"))" "(. js/document getElementsByClassName \"dots-game\")" "(. js/document getElementByClassName \"dots-game\")" "js/document" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(game-board {} nil)" "(in-ns 'dots.components.board)" "(browser-repl)" "(run)" "(in-ns 'dots.server)" "(run)" "(in-ns 'dots.components.board)" ":cljs/quit" "(browser-repl)" "(run)" "(let [coll [2 3 5 8]
                      safesub (comp #(Math/abs %) -)]
                  (map safesub coll (rest coll)))" "(let [coll [2 3 5 8]]
                  (map (comp #(Math/abs %) -) coll (rest coll)))" "(map (comp #(Math/abs %) -) [-1 -2 -3])" "(comp #(Math/abs %) -)" "(let [coll [2 3 5 8]]
                  (map #(Math/abs %) (map - coll (rest coll))))" "(map #(Math/abs %) [-1 -2 -3])" "(apply Math/abs [-1 -2 -3])" "(let [coll [2 3 5 8]]
                  (map - coll (rest coll)))" "(let [coll [2 3 5 8]]
                  (map - coll (rest coll))))" "(let [coll [2 3 5 8]]
                  (apply #(Math/abs %) (map - coll (rest coll))))" "(Math/abs -1)" "(map Math/abs '(-1 -2 -3))" "(apply Math/abs '(-1 -2 -3))" "(let [coll [2 3 5 8]]
                  (apply Math/abs (map - coll (rest coll))))" "(apply Math/abs (map - coll (rest coll)))" "(let [coll [2 3 5 8]]
                  (map #(-> % %2 - Math/abs) coll (rest coll)))" "(let [coll [2 3 5 8]]
                  (map #(-> % - Math/abs) coll (rest coll)))" "(let [coll [2 3 5 8]]
                  (map - coll (rest coll)))" "(map - coll (rest coll))" "(let [coll [2 3 5 8]]
                  (map #(-> % - Math/abs) coll (rest coll)))" "(Math/abs -1)" "abs" "?" "(ns courses.models.db)" "(ns user)" "(ns 'user)" "(in-ns 'courses.models.db)" "(alter-var-root #'fooSys component/start)" "pooled-db" "(let [conn (:connection fooSys)]
                     (sql/query conn [\"select * from section\"]))" "(alter-var-root #'fooSys component/start)" "(alter-var-root #'fooSys component/stop)" "(let [conn (:connection fooSys)]
                     (sql/query conn [\"select * from section\"]))" "(alter-var-root #'fooSys component/start)" "(let [conn (:connection fooSys)]
                     (sql/query conn [\"select * from section\"]))" "(alter-var-root #'fooSys component/start)" "(realized? pooled-db)" "pooled-db" "(alter-var-root #'fooSys component/stop)" "fooSys" "(let [conn (:connection fooSys)]
                     (sql/query conn [\"select * from section\"]))" "(:connection fooSys)" "fooSys" "fooDB" "(alter-var-root #'fooSys component/start)" "fooSys" "(def fooSys (system)
                     )" "fooDB" "(system)" "(system [])" "system" "fooDB" "(def fooDB (new-db))" "fooDB" "(def fooDB (new-db))" "fooDB" "(get-in fooDB [:connection :datasource])" "(.stop fooDB)" "(.start fooDB)" "pooled-db" "(let [conn (:connection fooDB)]
                     (sql/query conn [\"select * from section\"]))" "pooled-db" "(sql/with-db-connection [conn (:connection fooDB)]
                     (sql/query conn [\"select * from section\"]))" "(let [conn (get-in fooDB [:connection :datasource])]
                     (sql/query conn [\"select * from section\"]))" "(let [conn (:connection fooDB)]
                     (sql/query conn [\"select * from section\"]))" "(.start fooDB)" "fooDB" "(def fooDB (new-db))" "(let [conn (db-connection)]
                     (do (sql/query conn [\"select * from section\"])
                         (. (:datasource conn) close)))" "(let [conn (db-connection)]
                     (do (sql/query conn [\"select * from section\"])
                         (. conn close)))" "(let [conn (db-connection)]
                     (sql/query conn [\"select * from section\"]))" "(let [conn (db-connection)]
                     (. (:datasource conn) open))" "BoneCPDataSource" "(let [conn (db-connection)]
                     (:datasource conn))" "(let [conn (db-connection)]
                     conn)" "(let [conn (db-connection)]
                     (. (:datasource conn) close))" "(let [conn (db-connection)]
                     conn)" "(let [conn (db-connection)]
                     (. conn close))" "(in-ns 'courses.models.db)" "(in-ns 'courses.core)" "exit" "xit" "exit" "exit'" "(not false)" "(browser-repl)" "(server-browser)" "(run)" "(in-ns 'kanfold.core)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" "(browser-repl
                 )" "(run)" "(get {0 \"hey\"} 0)" "(get 0 {0 \"hey\"})" "(run)" "app-state" "(in-ns 'kanfold.core)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" "(. js/console (log (dom/render-to-str (om/build ticket {:title \"Foo\" :description \"Bar\"
                                                                      }))))" "(. js/console (log (dom/render-to-str (om/build ticket nil))))" "(in-ns 'kanfold.core)" "(browser-repl)" "(run)" ":cljs/quit" "p/panel" "(in-ns 'kanfold.core)" "(browser-repl)" "(run)" "(p/panel
   {:header \"Hey\"
    :list-group (d/ul {:class \"list-group\"}
                      (d/li {:class \"list-group-item\"} \"Item 1\")
                      (d/li {:class \"list-group-item\"} \"Item 2\")
                      (d/li {:class \"list-group-item\"} \"Item 3\"))}
   nil)" "(in-ns 'kanfold.core)" "(browser-repl)" "(run)" "(in-ns 'kanfold.core)" "(browser-repl)" "(run)" "(in-ns 'kanfold.core)" "(browser-repl)" "(run)" "build bucket))" "(dom/render-to-str (om/build bucket {}))" "(in-ns 'kanfold.core)" "(browser-repl)" "(dom/render-to-str (om/build bucket {}))" "(run)" "(dom/render-to-str (om/build bucket {}))" "(in-ns 'kanfold.core)" "(browser-repl)" "(run)" "(in-ns 'kanfold.core)" "(browser-repl)" "(run)" ":cljs/quit" "(require '[om-bootstrap.panel :as p])" "(require ['om-bootstrap.panel :as p])" "(p/panel)" "(in-ns 'kanfold.core)" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" ":cljs/quit")