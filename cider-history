;; -*- coding: utf-8-unix -*-
;; Automatically written history of CIDER REPL session
;; Edit at your own risk

("(or nil {})" "(keyword \"book:isbn\")" "(rget cli \"/Catalog/Publishers/McGraw-Hill/\")" "(def cli (nuxeo-client \"default-domain\" -auth))" "(rget cli \"/Catalog/Publishers/McGraw-Hill/\")" "(def cli (nuxeo-client \"default-domain\"))" "(in-ns 'nuxeo-client.core)" "(rget cli \"/Catalog/Publishers/McGraw-Hill/\")" "(def cli (nuxeo-client \"default-domain\"))" "(rget cli \"/Catalog/Publishers/McGraw-Hill/\")" "(def cli (nuxeo-client))" "(rget cli \"/Catalog/Publishers/McGraw-Hill/\")" "(rget \"/Catalog/Publishers/McGraw-Hill/\")" "(nuxeo-client)" "(in-ns 'nuxeo-client.core)" "(rget cli \"/Catalog/Publishers/McGraw-Hill/\")" "(rget \"/Catalog/Publishers/McGraw-Hill/\")" "(def cli (nuxeo-client)
                     )" "(rget \"/Catalog/Publishers/McGraw-Hill/\")" "(.rget (NuxeoClient.))" "(.rget NuxeoClient)" "NuxeoClient" "(clojure.reflect/type-reflect cli)" "(clojure.reflect/type-reflect NuxeoClient)" "(clojure.reflect/type-reflect cli)" "cli" "(.rget cli)" "cli" "(def cli (nuxeo-client)
                     )" "(nuxeo-client)" "(rget (nuxeo-client) \"/Catalog/Publishers/McGraw-Hill/\")" "(.rget cli)" "(cli/rget)" "(def cli (nuxeo-client))" "(nuxeo-client)" "(rget (nuxeo-client) \"/Catalog/Publishers/McGraw-Hill/\")" "(rget \"/Catalog/Publishers/McGraw-Hill/\")" "(in-ns 'nuxeo-client.core)" "(rget \"/Catalog/Publishers/McGraw-Hill/\")" "(in-ns 'nuxeo-client.core)" "(rget \"/Catalog/Publishers/McGraw-Hill/\")" "(rget cli \"/Catalog/Publishers/McGraw-Hill/\")" "(def cli (nuxeo-client))" "(in-ns 'nuxeo-client.core)" "(rget cli \"/Catalog/Publishers/McGraw-Hill/\")" "(def cli (nuxeo-client))" "(rget cli \"/Catalog/Publishers/McGraw-Hill/\")" "(rget \"/Catalog/Publishers/McGraw-Hill/\")" "(def cli (nuxeo-client))" "(http-get \"/Catalog/Publishers/McGraw-Hill/\")" "(def cli (nuxeo-client))" "(.get cli \"/Catalog/Publishers/McGraw-Hill/\")" "(def cli (nuxeo-client))" "(nuxeo-client)" "(client/get (str api-root workspace-root \"/Catalog/Publishers/McGraw-Hill/\") {:basic-auth [(:user auth) (:password auth)] :as :json})
                               " "(client/get (str api-root workspace-root \"/Catalog/Publishers/McGraw-Hill/\") {:basic-auth [(:user auth) (:password auth)]})
                               " "(client/get (str api-root workspace-root \"/Catalog/Publishers/McGraw-Hill/1001%20Ways%20To%20Save%20Money%20.%20.%20.%20and%20Still%20Have%20a%20Dazzling%20Wedding\") {:basic-auth [(:user auth) (:password auth)]})
                               " "(client/get (str api-root workspace-root \"/\" user-content-folder) {:basic-auth [(:user auth) (:password auth)]})
                               " "(client/get (str api-root workspace-root user-content-folder) {:basic-auth [(:user auth) (:password auth)]})
                               " "api-root" "(in-ns 'nuxeo-client.core)" "(in-ns nuxeo-client.core)" "(ns user)" "(ns nuxeo-client.core)" "(in-ns 'nuxeo-client.core)" "(client/get (str api-root workspace-root))" "workspace-root" "(client/get api-root)" "(client)" "client" "api-root" "(in-ns 'nuxeo-client.core)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" "(start-figwheel)" ":cljs/quit" "(browser-repl)" "(run)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" "(repl)" "(+ 1 2)" "(browser-repl)" "(run)" "(browser-repl)" "(ns dots.dev)" ":cljs/quit" "(+ 1 2)" "(browser-repl)" "(apply merge (map column-state (range 6)))" "(column-state 1)" "(defn column-state [column] 
               {(key-or-int column \"col-\")
                {:column column
                 :rows-map (zipmap (map #(key-or-int % \"row-\") (range 6)) (repeat 6 :blue))}})" "(column-state 1)" "(defn column-state [column] 
               {(key-or-int column \"col-\")
                {:column column
                 :rows-map (zipmap (map #(key-or-int % \"row-\") (range 6) (repeat 6 :blue)))}})" "(key-or-int :col-1 \"-\")" "(key-or-int 1 \"col-\")" "(defn key-or-int
  [i prefix-or-sep]
  (cond
   (integer? i) (->> i (str prefix-or-sep) keyword)
   (keyword? i) (-> i
                    name
                    (clojure.string/split (re-pattern prefix-or-sep))
                    last
                    parse-int)))
" "(parse-int \"1\")" "(defn parse-int [s]
               (. Integer parseInt s))" "(defn key-or-int
  [i prefix-or-sep]
  (cond
   (integer? i) (->> i (str prefix-or-sep) keyword)
   (keyword? i) (-> i
                    name
                    (clojure.string/split (re-pattern prefix-or-sep))
                    last
                    #(. Integer parseInt %))))
" "(defn key-or-int
  [i prefix-or-sep]
  (cond
   (integer? i) (->> i (str prefix-or-sep) keyword)
   (keyword? i) (-> i
                    name
                    (clojure.string/split (re-pattern prefix-or-sep))
                    last
                    (. Integer parseInt))))
" "(. Integer parseInt \"1\")" "(Integer. parseInt \"1\")" ":cljs/quit" "(+ 1 2)" "(browser-repl)" "(run)" "(clojure.string/split \"foo-bar\" #\"-\")" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" "(run)" "(+ 1 2)" "(browser-repl)" "(run)" ":cljs/quit" "(columns)" "columns" "(columns)" "(in-ns 'dots.appstate)" "(browser-repl)" "(run)" ":cljs/quit" "[:a 1]" "(browser-repl)" "(run)" ":cljs/quit" "[:a 1]" "(browser-repl)" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(in-ns 'dots.components.board)" "(browser-repl)" "(run)" "(let [x 1] (inc x))" "(+ 1 1)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" "(ns dots.server)" "(is-dev?)" "(ns dots.dev)" "(ns 'dots.dev)" "(in-ns 'dots.components.board)" "(run)" "(let [x 1]
        (+ 1 x))" "(+ 1 2)" "(get {0 :a} 0)" "(name {0 :green, 1 :yellow, 2 :red, 3 :yellow, 4 :purple, 5 :blue})" "(0 {0 :green, 1 :yellow, 2 :red, 3 :yellow, 4 :purple, 5 :blue})" "(name {0 :green, 1 :yellow, 2 :red, 3 :yellow, 4 :purple, 5 :blue})" "(name 0)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(map (fn [[col m]] {col m}) {0 {:foo 1} 1 {:foo 2}})" "(map (fn [[col m]] m) {0 {:foo 1} 1 {:foo 2}})" "(apply merge (for [col (range 6)]
             {col {:column col
                   :rows-map (zipmap (range 6)
                                     (repeat 6 :blue))}}))" "(for [col (range 6)]
             {col {:column col
                   :rows-map (zipmap (range 6)
                                     (repeat 6 :blue))}})" "(doseq [col (range 6)]
             {col {:column col
                   :rows-map (zipmap (range 6)
                                     (repeat 6 :blue))}})" "(repeat 6 1)" "(doseq [col (range 6)]
             {col {:column col
                   :rows-map (zipmap (range 6)
                                     :blue)}})" "(def board-size 6)" "(doseq [col (range board-size)]
             {col {:column col
                   :rows-map (zipmap (range board-size)
                                     :blue)}})" "(apply merge (for [col (range board-size)]
                          {col {:column col
                                :rows-map (zipmap (range board-size)
                                                  :blue)}}))" "(apply merge (doseq [col (range board-size)]
                          {col {:column col
                                :rows-map (zipmap (range board-size)
                                                  :blue)}}))" "(browser-repl)" "(run)" "(set [1 2 3 3])" "(set 1 2 3 4 5)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(first [1 2])" "(map first [1 2] [3 4])" "(map + 1 2 3)" "(+ 1 2)" "(let [dots [{:foo 1 :bar 2} {:foo 2 :bar 2}]
                 max-dots (apply max (map :foo dots))]
             (into [] (filter #(= max-dots (:foo %)) dots)))
             " "(let [dots [{:foo 1 :bar 2} {:foo 2 :bar 2}]
                 max-dots (apply max (map :foo dots))]
             (filter #(= max-dots (:foo %)) dots))
             " "(apply max (map :foo [{:foo 1 :bar 2} {:foo 2 :bar 2}]))" "(browser-repl)" "(run)" ":cljs/quit" "(apply max (map :foo [{:foo 1} {:foo 2}]))" "(map :foo [{:foo 1} {:foo 2}])" "(max (map :foo [{:foo 1} {:foo 2}]))" "(keyword \"hey\")" "(key \"hey\")" "(and 1 nil true)" "(and 1 0 true)" "(and true true true)" "(browser-repl)" "(run)" ":cljs/quit" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(in-ns 'dots.chans)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" "(run)" ":cljs/quit" "(run)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" "(clojure.string/reverse \"Hello World\")" ":cljs/quit" "(def c (async/chan))
(def p (async/pub c :topic))
(async/put! c {:topic :foo})" "(in-ns 'dots.components.board)" "(browser-repl)" "(run)" ":cljs/quit" "(go-loop)" "(require-macros '[cljs.core.async.macros :refer [go-loop]])
                               " "(+ 1 2)" "(go (let [c (async/chan)]
                             (async/put! c {:topic :foo})
                             (:topic (<! c))))
                               " "(+ 1 2)" "(go (let [c (async/chan)]
                             (async/put! c {:topic :foo})
                             (let [v (<! c)]
                               (println v))))" "(+ 1 2)" "(go (let [c (async/chan)]
                             (>! c {:topic :foo})
                             (let [v (<! c)]
                               (println v))))" "(+ 1 2)" "(go (let [c (async/chan)]
                             (async/put! c {:topic :foo})
                             (let [v (<! c)]
                               (println v))))" "(let [x {}]
                         (go (let [c (async/chan)]
                               (async/put! c {:topic :foo})
                               (let [v (<! c)]
                                 (merge x {:foo v}))))
                         x)" "(go (let [c (async/chan)]
                             (async/put! c {:topic :foo})
                             (let [v (<! c)]
                               (println v))))" "(let [x {}]
                         (go (let [c (async/chan)]
                               (async/put! c {:topic :foo})
                               (let [v (<! c)]
                                 (merge x {:foo v}))))
                         x)" "(let [x {}]
                         (go (let [c (async/chan)]
                               (async/put! c {:topic :foo})
                               (let [v (<! c)]
                                 (merge x {:foo v}))))
                         x)
                               " "(let [x {}]
                         (go (let [c (async/chan)]
                               (async/put! c {:topic :foo})
                               (let [v (<! c)]
                                 (merge x {:foo v}))))
                         x)" "(let [x {}]
                         (go (let [c (async/chan)]
                               (async/put! c {:topic :foo})
                               (let [v (<! c)]
                                 (merge x {:foo v}))))
                         )" "(let [x {}]
                         (go (let [c (async/chan)]
                               (async/put! c {:topic :foo})
                               (let [v (<! c)]
                                 (merge x {:foo v})))))" "(let [x {}]
                         (go (let [c (async/chan)]
                               (async/put! c {:topic :foo})
                               (let [v (<! c)]
                                 (merge x {:foo v}))))
                         x)
                               " "(go (let [c (async/chan)]
                             (async/put! c {:topic :foo})
                             (let [v (<! c)]
                               (println v))))" "(go (let [c (async/chan)]
                             (async/put! c {:topic :foo})
                             (let [v (<! c)]
                               println v)))" "(go (let [c (async/chan)]
                             (async/put! c {:topic :foo})
                             (let [v (<! c)]
                               {:foo v})))" "(let [c (async/chan)]
                         (async/put! c {:topic :foo})
                         (go (let [v (<! c)]
                               {:foo v})))" "(let [c (async/chan)]
                         (async/put! c {:topic :foo})
                         (go (type (<! c))))" "(let [c (async/chan)]
                         (async/put! c {:topic :foo}))
                         (go (type (<! c))))" "(println (go (<! my-chan)))" "(type (go (async/<! my-chan)))" "(go (async/<! my-chan))" "(type my-chan)" "my-chan" "(def my-chan (let [c (async/chan)]
                                      (async/put! c {:topic :foo})
                                      c))" "(let [c (async/chan)]
                         (async/put! c {:topic :foo})
                         c)" "(let [c (async/chan)]
                         (async/put! c {:topic :foo})
                         )" "(let [c (async/chan)]
                         (async/put! c {:topic :foo})
                         (async/take! c #(:topic %)))" "(let [c (async/chan)]
                         (async/put! c {:topic :foo})
                         (go (async/take! c #(:topic %))))" "(let [c (async/chan)]
                         (async/put! c {:topic :foo})
                         (go (:topic (async/take! c))))" "(let [c (async/chan)]
                         (async/put! c {:topic :foo})
                         (go (:topic (<! c))))" "(let [c (async/chan)]
                         (async/put! c {:topic :foo}))
                         (go (:topic (<! c))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (go (:topic (<! c))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (type (go <! (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (go <! (go (<! c))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (keys (go <! (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (:topic (go <! (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (clj->js (go <! (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (go <! (go (<! c))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (type (clj->js (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (:topic (clj->js (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (clj->js (go (<! c))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (println (clj->js (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (println (cljs->js (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (println (go (<! c))))" "(let [c (async/chan)]
                         (do
                           (go (>! c {:topic :foo}))
                           (println (go (<! c)))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (println (go (<! c))))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo}))
                         (go (<! c)))" "(let [c (async/chan)]
                         (go (>! c {:topic :foo})))" "(in-ns 'dots.components.board)" "(browser-repl)" "(run)" ":cljs/quit" "(let [c (chan)]
                         c
                         )" "(put!
 
 )" "(in-ns 'dots.components.board)" "(in-ns 'dots.core)" "(in-ns 'dots.components.main)" "(in-ns 'dots.main)" "(browser-repl)" "(run)" "(let [publisher (async/chan)
                   publication (async/pub publisher #(:topic %))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (async/sub publication :foo subscriber)
               (take-and-print subscriber \"I'm the subscriber!\")
               (async/go (async/>! publisher {:topic :foo})))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (do 
                (async/sub publication :foo subscriber)
                (take-and-print subscriber \"I'm the subscriber!\")
                (async/go (async/>! publisher {:foo \"hey buddy\"}))))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (doall 
                (async/sub publication :foo subscriber)
                (take-and-print subscriber \"I'm the subscriber!\")
                (async/go (async/>! publisher {:foo \"hey buddy\"}))))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (async/sub publication :foo subscriber)
               (take-and-print subscriber \"I'm the subscriber!\")
               (async/go (async/>! publisher {:foo \"hey buddy\"})))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (async/sub publication :foo subscriber)
               (take-and-print subscriber {:foo \"foo\"})
               (async/go (async/>! publisher {:foo \"hey buddy\"})))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (async/sub publication :foo subscriber)
               (take-and-print subscriber {:foo \"foo\"})
               (async/go (>! publisher {:foo \"hey buddy\"})))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (async/sub publication :foo subscriber)
               (take-and-print subscriber {:foo \"foo\"}))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (async/sub publication :foo subscriber)
               (take-and-print subscriber \"foo\"))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (sub publication :foo subscriber)
               (take-and-print subscriber \"foo\"))" "(let [publisher (async/chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (async/chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (take-and-print subscriber \"foo\"))" "(let [publisher (chan)
                   publication (async/pub publisher (fn [m] m))
                   subscriber (chan)
                   take-and-print (fn [ch prefix] 
                                    (async/go-loop []
                                      (println prefix \": \" (async/<! ch))
                                      (recur)))]
               (take-and-print subscriber \"foo\"))" "(require '[clojure.core.async :as async])" ":cljs/quit" "(require '[clojure.core.async :as async])" "(browser-repl)" "(run)" "(browser-repl)" "(run)" "(repeat 6)" "(repeat 1)" "(def -dots (let [board-size 6] 
             (for [col (range board-size) row (range board-size)]
               {:column col :row row :color (rand-colors nil)})))" "-dots" "(def -dots (let [board-size 6] 
             (for [col (range board-size) row (range board-size)]
               {:column col :row row :color (rand-colors nil)})))" "(map (fn [x y] {:col x :row y}) (range 6) (range 6))" "(map {:col % :row %2} [(range 6) (range 6)])" "(map {:col % :row %2} (range 6) (range 6))" "(map #({:col % :row %2}) (range 6) (range 6))" "(map {:col % :row %2} (range 6) (range 6))" "(let [board-size 6
                             dots (for [col (range board-size) row (range board-size)]
                                    {:column col :row row :color (rand-colors nil)})]
                         (apply d/div #js {:className \"board\"} (om/build-all dot dots)))" "(let [board-size 6
                             dots (for [col (range board-size) row (range board-size)]
                                    {:column col :row row :color (rand-colors nil)})]
                         (om/build-all dot dots))" "(in-ns 'dots.components.board)" "(browser-repl)" "(run)" ":cljs/quit" "(let [board-size 6
                             dots (for [col (range board-size) row (range board-size)]
                                    {:column col :row row :color (rand-colors nil)})]
                         (om/build-all dot dots))" "(in-ns 'dots.components.board)" "(+ 1 1)" "(browser-repl)" "(run)" ":cljs/quit" "(+ 1 1)" "(browser-repl)" ":cljs/quit" "(+ 1 1 )" "q" "(browser-repl)" "(run)" "x" "(def x (for [col (range 6) row (range 6)] {:column col :row row}))" "(for [col (range 6) row (range 6)] {:column col :row row})" "(map #(zipmap [:col :row] [% %2]) (range 6) (range 6))" "(map #(zipmap [:col :row] % %2) (range 6) (range 6))" "(map #(zipmap [:col :row] %) (range 6) (range 6))" "(zipmap [:col :row] [1 2])" "(apply #(zipmap [:col :row] %) [1 2])" "(apply #(zipmap [:col :row] %) [(range 6) (range 6)])" "(apply #(zipmap [:col :row] %) [[(range 6) (range 6)]])" "(apply zipmap [[:col :row] [(range 6) (range 6)]])" "(apply zipmap [:col :row] [[(range 6) (range 6)]])" "(apply zipmap [:col :row] [(range 6) (range 6)])" "(zipmap [:col :row] [(range 6) (range 6)])" "(zipmap :col :row [(range 6) (range 6)])" "[(range 6) (range 6)]" "(range 6)" "(range 5)" "(str 23 \"px\")" "(str 23)" "(browser-repl)" "(run)" ":cljs/quit" "(+ 1 1)" "(. js/console log \"Hey\")" "(browser-repl)" "(run)" "(start-figwheel)" "(run)" "(. js/console log \"Hey\")" "(browser-repl)" "(run)" ":cljs/quit'" "(alert
            )" "(browser-repl)" ":cljs/quit" "(. js/alert \"Hey!\")" "(browser-repl)" "(run)" "(browser-repl)" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" "-server" "(def -server (run))" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" ":cljs/quit" "(browser-repl)" "(run)" "(d/div #js {:className \"marq\"} (om/build-all color-letter (colorize-word \"SCORE\")))
                               " "(d/div #js {:className \"marq\"} (om/build-all color-letter (colorize-word \"SCORE\"))
                               )" "(d/div #js {:className \"marq\"} (om/build-all color-letter (colorize-word \"SCORE\")))" "(apply d/div #js {:className \"marq\"} (om/build-all color-letter (colorize-word \"SCORE\")))" "(om/build-all color-letter (colorize-word \"SCORE\"))" "(colorize-word \"SCORE\")" "(defn colorize-word [word]
  (map (fn [x c] {:className (name c) :letter x}) word (rand-colors nil)))
" "(defn colorize-word [word]
  (map (fn [x c] {:className (name c) :letter x}) word (rand-colors)))
" "(in-ns 'dots.components.screen)" "(browser-repl)" "(run)" "(rand-colors)" "dot-colors" "(dot-colors)" "(om/build (d/span {:className (name \"foo\")} \"S\") nil)" "(om/build (d/span {:className (name \"foo\")} \"S\")
                     )" "(in-ns 'dots.components.screen)" "(om/build (d/span {:className (name \"foo\")} \"S\")
                     )" "(+ 1 1)" "(browser-repl)" ":cljs/quit" "(+ 1 1)" "(colorize-word \"BOO\")" "(browser-repl)" "(run)" ":cljs/quit" "(+ 1 1)" "(colorize-word \"BOO\")" "(in-ns 'dots.components.screen)" "(browser-repl)" ":cljs/quit" "(run)" ":cljs/quit" "(browser-repl)" "(run)" ":cljs/quit" "(concat [1 2 3 4])" "(om/build-all header-col [{:title \"score\" :val 0} {:title \"time\" :val 60}])" "(om/build-all header-col nil [{:state {:title \"score\" :val 0}} {:state {:title \"time\" :val 60}}])" "(om/build-all header-col [{:title \"score\" :val 0} {:title \"time\" :val 60}])" "(om/build-all header-call [{:title \"score\" :val 0} {:title \"time\" :val 60}])" "(in-ns 'dots.components.board)" "(browser-repl)" ":cljs/quit" "(. js/document getElementById \"dots-game-container\")" "(browser-repl)" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" ":cljs/quit" "(. js/document getElementById \"app\")" "(browser-repl)" ":cljs/quit" "(. js/document getElementById \"dots-game-container\")" "(. js/document getElementById \"main\")" "(. js/document getElementsByClassName \"dots-game\")" "(first (. js/document getElementsByClassName \"dots-game\"))" "(. js/document getElementsByClassName \"dots-game\")" "(. js/document getElementByClassName \"dots-game\")" "js/document" "(browser-repl)" "(run)" ":cljs/quit" "(browser-repl)" "(run)" "(browser-repl)" "(run)" ":cljs/quit" "(game-board {} nil)" "(in-ns 'dots.components.board)" "(browser-repl)" "(run)" "(in-ns 'dots.server)" "(run)" "(in-ns 'dots.components.board)" ":cljs/quit" "(browser-repl)" "(run)" "(let [coll [2 3 5 8]
                      safesub (comp #(Math/abs %) -)]
                  (map safesub coll (rest coll)))")